mod code;
mod error;
mod file;
mod parser;

use code::get_connection_type_name;
use error::IOErrorToError;
pub use error::{Error, Result};

use file::MarkedFile;
use parser::ParsedTableMacro;
pub use parser::FILE_SIGNATURE;
use std::collections::HashMap;
use std::fmt::Display;
use std::path::PathBuf;

/// Individual Options for a given table
#[derive(Debug, Clone, Default)]
pub struct TableOptions<'a> {
    /// Ignore a specific table
    ignore: Option<bool>,

    /// Names used for autogenerated columns which are NOT primary keys (for example: `created_at`, `updated_at`, etc.).
    autogenerated_columns: Option<Vec<&'a str>>,

    #[cfg(feature = "tsync")]
    /// Adds #[tsync] attribute to structs (see https://github.com/Wulf/tsync)
    tsync: Option<bool>,

    #[cfg(feature = "async")]
    /// Uses diesel_async for generated functions (see https://github.com/weiznich/diesel_async)
    use_async: Option<bool>,

    /// Generates serde::Serialize and serde::Deserialize derive implementations
    use_serde: Option<bool>,

    /// Only Generate the necessary derives for a struct
    only_necessary_derives: Option<bool>,

    /// Indicate that this table is read-only
    read_only: Option<bool>,

    /// Indicated whether or not to generate "impls"
    impls: Option<bool>,

    /// Use "str" over "String" for "Create*" structs
    create_str_over_string: Option<bool>,
}

impl<'a> TableOptions<'a> {
    pub fn get_ignore(&self) -> bool {
        self.ignore.unwrap_or_default()
    }

    #[cfg(feature = "tsync")]
    pub fn get_tsync(&self) -> bool {
        self.tsync.unwrap_or_default()
    }

    #[cfg(feature = "async")]
    pub fn get_async(&self) -> bool {
        self.use_async.unwrap_or_default()
    }

    pub fn get_serde(&self) -> bool {
        self.use_serde.unwrap_or(true)
    }

    pub fn get_only_necessary_derives(&self) -> bool {
        self.only_necessary_derives.unwrap_or(false)
    }

    pub fn get_autogenerated_columns(&self) -> &[&'_ str] {
        self.autogenerated_columns.as_deref().unwrap_or_default()
    }

    pub fn get_read_only(&self) -> bool {
        self.read_only.unwrap_or_default()
    }

    pub fn get_generate_impls(&self) -> bool {
        self.impls.unwrap_or(true)
    }

    pub fn get_create_str(&self) -> bool {
        self.create_str_over_string.unwrap_or(false)
    }

    pub fn ignore(self) -> Self {
        Self {
            ignore: Some(true),
            ..self
        }
    }

    #[cfg(feature = "tsync")]
    pub fn tsync(self) -> Self {
        Self {
            tsync: Some(true),
            ..self
        }
    }

    #[cfg(feature = "async")]
    pub fn use_async(self) -> Self {
        Self {
            use_async: Some(true),
            ..self
        }
    }

    pub fn disable_serde(self) -> Self {
        Self {
            use_serde: Some(false),
            ..self
        }
    }

    pub fn only_necessary_derives(self) -> Self {
        Self {
            only_necessary_derives: Some(true),
            ..self
        }
    }

    pub fn autogenerated_columns(self, cols: Vec<&'a str>) -> Self {
        Self {
            autogenerated_columns: Some(cols),
            ..self
        }
    }

    pub fn disable_impls(self) -> Self {
        Self {
            impls: Some(false),
            ..self
        }
    }

    pub fn create_str_over_string(self) -> Self {
        Self {
            create_str_over_string: Some(true),
            ..self
        }
    }

    pub fn set_read_only(&mut self, bool: bool) {
        self.read_only = Some(bool);
    }

    /// Fills any `None` properties with values from another TableConfig
    pub fn apply_defaults(&self, other: &TableOptions<'a>) -> Self {
        Self {
            ignore: self.ignore.or(other.ignore),
            #[cfg(feature = "tsync")]
            tsync: self.tsync.or(other.tsync),
            #[cfg(feature = "async")]
            use_async: self.use_async.or(other.use_async),
            autogenerated_columns: self
                .autogenerated_columns
                .clone()
                .or_else(|| other.autogenerated_columns.clone()),

            use_serde: self.use_serde.or(other.use_serde),
            only_necessary_derives: self.only_necessary_derives.or(other.only_necessary_derives),
            read_only: self.read_only.or(other.read_only),
            impls: self.impls.or(other.impls),
            create_str_over_string: self.create_str_over_string.or(other.create_str_over_string),
        }
    }
}

#[derive(Debug, Clone)]
pub struct GenerationConfig<'a> {
    /// Specific Table options for a given table
    pub table_options: HashMap<&'a str, TableOptions<'a>>,
    /// Default table options, used when not in `table_options`
    pub default_table_options: TableOptions<'a>,
    /// Connection type to insert
    /// Example: "diesel::SqliteConnection"
    pub connection_type: String,
    /// diesel schema path to use
    /// Example: "crate::schema::"
    pub schema_path: String,
    /// model path to use
    /// Example: "crate::models::"
    pub model_path: String,
    /// Only generate common structs once and put them in a common file
    pub once_common_structs: bool,
    /// Only generate a single model file instead of a folder with a "mod.rs" and a "generated.rs"
    pub single_model_file: bool,
    /// Set which filemode to use
    pub file_mode: FileMode,
    /// A prefix of read-only tables
    pub read_only_prefix: Option<Vec<String>>,
    /// Only generate the "Connection" type once
    pub once_connection: bool,
    /// Lessen conflicts with diesel types
    pub lessen_conflicts: bool,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FileMode {
    /// Overwrite the file path, as long as a dsync signature is present
    Overwrite,
    /// Create a ".dsyncnew" file if changed
    NewFile,
    /// Do nothing for the file
    None,
}

impl GenerationConfig<'_> {
    pub fn table(&self, name: &str) -> TableOptions<'_> {
        let res = self
            .table_options
            .get(name)
            .unwrap_or(&self.default_table_options);

        let mut res = res.apply_defaults(&self.default_table_options);

        if let Some(ref read_only_prefix) = self.read_only_prefix {
            if read_only_prefix.iter().any(|v| name.starts_with(v)) {
                res.set_read_only(true);
            }
        }

        res
    }
}

/// Generate a model for a given schema
/// Model is returned and not saved to disk
pub fn generate_code(
    diesel_schema_file_contents: String,
    config: &GenerationConfig,
) -> Result<Vec<ParsedTableMacro>> {
    parser::parse_and_generate_code(diesel_schema_file_contents, config)
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FileChangesStatus {
    /// Status to mark unchanged file contents
    Unchanged,
    /// Status to mark unchanged files, because of some ignore rule (like [FileMode::None])
    UnchangedIgnored,
    /// Status to mark overwritten file contents
    Overwritten,
    /// Status to mark a ".dsyncnew" file being generated
    /// and the path to the original file
    NewFile(PathBuf),
    /// Status to mark file contents to be modified
    Modified,
    /// Status if the file has been deleted
    Deleted,
    /// Status if the file should be deleted, but is not because of some ignore rule (like [FileMode::None])
    DeletedIgnored,
}

impl Display for FileChangesStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                FileChangesStatus::Unchanged => "Unchanged",
                FileChangesStatus::UnchangedIgnored => "Unchanged(Ignored)",
                FileChangesStatus::Overwritten => "Overwritten",
                FileChangesStatus::Modified => "Modified",
                FileChangesStatus::Deleted => "Deleted",
                FileChangesStatus::DeletedIgnored => "Deleted(Ignored)",
                FileChangesStatus::NewFile(_) => "NewFile",
            }
        )
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FileChanges {
    /// File in question
    pub file: PathBuf,
    /// Status of the file
    pub status: FileChangesStatus,
}

impl FileChanges {
    pub fn new<P: AsRef<std::path::Path>>(path: P, status: FileChangesStatus) -> Self {
        Self {
            file: path.as_ref().to_owned(),
            status,
        }
    }

    /// Create a new instance based on if the input file is modified or not
    /// using either `status_modified` or `status_unmodified`
    pub fn from_markedfile_custom(
        marked_file: &MarkedFile,
        status_modified: FileChangesStatus,
        status_unmodified: FileChangesStatus,
    ) -> Self {
        if marked_file.is_modified() {
            Self::new(marked_file, status_modified)
        } else {
            Self::new(marked_file, status_unmodified)
        }
    }
}

impl From<&MarkedFile> for FileChanges {
    fn from(value: &MarkedFile) -> Self {
        Self::from_markedfile_custom(
            value,
            FileChangesStatus::Modified,
            FileChangesStatus::Unchanged,
        )
    }
}

/// The file extension to use for [FileMode::NewFile]
/// also adds another ".rs", so that IDE's can syntax highlight correctly
const DSYNCNEW: &str = ".dsyncnew.rs";

/// Write a [MarkedFile] depending on what [FileMode] is used and add it to [Vec<FileChanges>]
fn write_file(
    config: &GenerationConfig,
    mut file: MarkedFile,
    file_status: &mut Vec<FileChanges>,
) -> Result<()> {
    let (write, file_change_status) = match config.file_mode {
        FileMode::Overwrite => (true, FileChangesStatus::Modified),
        FileMode::NewFile => {
            let old_path = file.path;
            let mut file_name = old_path
                .file_name()
                .ok_or(Error::other("Expected file to have a file_name"))?
                .to_os_string();
            file_name.push(DSYNCNEW);

            file.path = old_path.clone();
            file.path.set_file_name(file_name);

            (true, FileChangesStatus::NewFile(old_path))
        }
        FileMode::None => (false, FileChangesStatus::UnchangedIgnored),
    };

    // additional "is_modified" check, because "newfile" changed the path and write would generate a file even if unchanged
    if write && file.is_modified() {
        file.write()?;
    }

    // set status to "Unchanged" if no change happened and to "UnchangedIgnored" if a change happened, but not written
    file_status.push(FileChanges::from_markedfile_custom(
        &file,
        file_change_status,
        FileChangesStatus::Unchanged,
    ));

    Ok(())
}

/// Generate all models for a given diesel schema input file
/// Models are saved to disk
pub fn generate_files(
    input_diesel_schema_file: PathBuf,
    output_models_dir: PathBuf,
    config: GenerationConfig,
) -> Result<Vec<FileChanges>> {
    let input = input_diesel_schema_file;
    let output_dir = output_models_dir;

    let generated = generate_code(
        std::fs::read_to_string(&input).attach_path_err(&input)?,
        &config,
    )?;

    if !output_dir.exists() {
        std::fs::create_dir(&output_dir).attach_path_err(&output_dir)?;
    } else if !output_dir.is_dir() {
        return Err(Error::not_a_directory(
            "Expected output argument to be a directory or non-existent.",
            output_dir,
        ));
    }

    let mut file_status = Vec::new();

    // check that the mod.rs file exists
    let mut mod_rs = MarkedFile::new(output_dir.join("mod.rs"))?;

    let mut common_file = MarkedFile::new(output_dir.join("common.rs"))?;

    // dont check file signature if a ".dsyncnew" file will be generated
    if config.file_mode != FileMode::NewFile {
        common_file.ensure_file_signature()?;
    }

    common_file.change_file_contents_no_modify(format!("{}\n", FILE_SIGNATURE));

    if config.once_common_structs {
        common_file.change_file_contents({
            let mut tmp = String::from(common_file.get_file_contents());
            tmp.push_str(&code::generate_common_structs(
                &config.default_table_options,
            ));
            tmp
        });
    }

    if config.once_connection {
        common_file.change_file_contents({
            let mut tmp = String::from(common_file.get_file_contents());
            if !common_file.is_empty() {
                tmp.push('\n');
            }
            tmp.push_str(&format!(
                "pub type {} = {};\n",
                get_connection_type_name(&config),
                config.connection_type
            ));
            tmp
        })
    }

    if !common_file.is_empty() {
        // always write the "mod" statement, even if "write_file" is not writing
        mod_rs.ensure_mod_stmt("common");
    }

    write_file(&config, common_file, &mut file_status)?;

    // pass 1: add code for new tables
    for table in generated.iter() {
        if config.once_common_structs && table.name == "common" {
            return Err(Error::other("Cannot have a table named \"common\" while having option \"once_common_structs\" enabled"));
        }

        let table_name = table.name.to_string();
        let table_dir = if config.single_model_file {
            output_dir.clone()
        } else {
            output_dir.join(&table_name)
        };

        if !table_dir.exists() {
            std::fs::create_dir(&table_dir).attach_path_err(&table_dir)?;
        }

        if !table_dir.is_dir() {
            return Err(Error::not_a_directory("Expected a directory", table_dir));
        }

        let table_file_name = if config.single_model_file {
            let mut table_name = table_name; // avoid a clone, because its the last usage of "table_name"
            table_name.push_str(".rs");
            table_name
        } else {
            "generated.rs".into()
        };

        let mut table_generated_rs = MarkedFile::new(table_dir.join(table_file_name))?;

        // dont check file signature if a ".dsyncnew" file will be generated
        if config.file_mode != FileMode::NewFile {
            table_generated_rs.ensure_file_signature()?;
        }

        table_generated_rs.change_file_contents(
            table
                .generated_code
                .as_ref()
                .ok_or(Error::other(format!(
                    "Expected code for table \"{}\" to be generated",
                    table.struct_name
                )))?
                .clone(),
        );

        write_file(&config, table_generated_rs, &mut file_status)?;

        if !config.single_model_file {
            let mut table_mod_rs = MarkedFile::new(table_dir.join("mod.rs"))?;

            table_mod_rs.ensure_mod_stmt("generated");
            table_mod_rs.ensure_use_stmt("generated::*");
            // always write the "mod" statement, even if "write_file" is not writing
            table_mod_rs.write()?;

            file_status.push(FileChanges::from(&table_mod_rs));
        }

        mod_rs.ensure_mod_stmt(table.name.to_string().as_str());
    }

    // pass 2: delete code for removed tables
    for item in std::fs::read_dir(&output_dir).attach_path_err(&output_dir)? {
        let item = item.attach_path_err(&output_dir)?;

        // check if item is a directory
        let file_type = item
            .file_type()
            .attach_path_msg(item.path(), "Could not determine type of file")?;
        if !file_type.is_dir() {
            continue;
        }

        // check if it's a generated file
        let generated_rs_path = item.path().join("generated.rs");
        if !generated_rs_path.exists()
            || !generated_rs_path.is_file()
            || !MarkedFile::new(generated_rs_path.clone())?.has_file_signature()
        {
            continue;
        }

        // okay, it's generated, but we need to check if it's for a deleted table
        let file_name = item.file_name();
        let associated_table_name = file_name.to_str().ok_or(Error::other(format!(
            "Could not determine name of file '{:#?}'",
            item.path()
        )))?;
        let found = generated.iter().find(|g| {
            g.name
                .to_string()
                .eq_ignore_ascii_case(associated_table_name)
        });
        if found.is_some() {
            continue;
        }

        match config.file_mode {
            FileMode::Overwrite => {
                // this table was deleted, let's delete the generated code
                std::fs::remove_file(&generated_rs_path).attach_path_err(&generated_rs_path)?;
                file_status.push(FileChanges::new(
                    &generated_rs_path,
                    FileChangesStatus::Deleted,
                ));
            }
            FileMode::NewFile | FileMode::None => {
                file_status.push(FileChanges::new(
                    &generated_rs_path,
                    FileChangesStatus::DeletedIgnored,
                ));
            }
        }

        // remove the mod.rs file if there isn't anything left in there except the use stmt
        let table_mod_rs_path = item.path().join("mod.rs");
        if table_mod_rs_path.exists() {
            let mut table_mod_rs = MarkedFile::new(table_mod_rs_path)?;

            table_mod_rs.remove_mod_stmt("generated");
            table_mod_rs.remove_use_stmt("generated::*");

            if table_mod_rs.get_file_contents().trim().is_empty() {
                if config.file_mode == FileMode::Overwrite {
                    let table_mod_rs = table_mod_rs.delete()?;
                    file_status.push(FileChanges::new(&table_mod_rs, FileChangesStatus::Deleted));
                } else {
                    file_status.push(FileChanges::new(
                        &table_mod_rs,
                        FileChangesStatus::DeletedIgnored,
                    ));
                }
            } else {
                // not using "write_file" because of custom "NewFile" handling
                let (write, file_change_status) = match config.file_mode {
                    FileMode::Overwrite => (true, FileChangesStatus::Modified),
                    FileMode::NewFile | FileMode::None => {
                        (false, FileChangesStatus::UnchangedIgnored)
                    }
                };

                if write && table_mod_rs.is_modified() {
                    table_mod_rs.write()?;
                }

                // set status to "Unchanged" if no change happened and to "UnchangedIgnored" if a change happened, but not written
                file_status.push(FileChanges::from_markedfile_custom(
                    &table_mod_rs,
                    file_change_status,
                    FileChangesStatus::Unchanged,
                ));
            }
        }

        // delete the table dir if there's nothing else in there
        let is_empty = item
            .path()
            .read_dir()
            .attach_path_err(item.path())?
            .next()
            .is_none();
        if is_empty {
            std::fs::remove_dir(item.path()).attach_path_err(item.path())?;
        }

        // dont remove "mod" statement on delete for anything other than ::Overwrite
        if config.file_mode == FileMode::Overwrite {
            // remove the module from the main mod_rs file
            mod_rs.remove_mod_stmt(associated_table_name);
        }
    }

    // always write the "mod" statement, even if "write_file" is not writing
    mod_rs.write()?;

    file_status.push(FileChanges::from(&mod_rs));

    Ok(file_status)
}
