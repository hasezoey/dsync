use clap::{Parser, Subcommand, ValueEnum};
use clap_complete::Shell;
use std::path::PathBuf;

#[derive(Debug, Parser, Clone, PartialEq)]
#[command(author, version, about, long_about = None)]
#[command(bin_name("dsync"))]
#[command(disable_help_subcommand(true))] // Disable subcommand "help", only "-h" or "--help" should be used
#[command(subcommand_negates_reqs(true))]
#[command(infer_subcommands(true))]
pub struct CliDerive {
    // use extra struct, otherwise clap subcommands require all options
    #[clap(flatten)]
    pub args: Option<MainOptions>,

    #[command(subcommand)]
    pub subcommands: Option<SubCommands>,
}

#[derive(Debug, Subcommand, Clone, PartialEq)]
pub enum SubCommands {
    /// Generate shell completions
    Completions(CommandCompletions),
}

#[derive(Debug, Parser, Clone, PartialEq)]
pub struct CommandCompletions {
    /// Set which shell completions should be generated
    /// Supported are: Bash, Elvish, Fish, PowerShell, Zsh
    #[arg(short = 's', long = "shell", value_enum)]
    pub shell: Shell,
    /// Output path where to output the completions to
    /// Not specifying this will print to STDOUT
    #[arg(short = 'o', long = "out")]
    pub output_file_path: Option<PathBuf>,
}

#[derive(Debug, Parser, Clone, PartialEq)]
pub struct MainOptions {
    /// Input diesel schema file
    #[arg(short = 'i', long = "input")]
    pub input: PathBuf,

    /// Output file, stdout if not present
    #[arg(short = 'o', long = "output")]
    pub output: PathBuf,

    /// adds the #[tsync] attribute to all structs; see https://github.com/Wulf/tsync
    #[arg(long = "tsync")]
    #[cfg(feature = "tsync")]
    pub tsync: bool,

    /// uses diesel_async for generated functions; see https://github.com/weiznich/diesel_async
    #[arg(long = "async")]
    #[cfg(feature = "async")]
    pub use_async: bool,

    /// List of columns which are automatically generated but are not primary keys (for example: "created_at", "updated_at", etc.)
    #[arg(short = 'g', long = "autogenerated-columns")]
    pub autogenerated_columns: Option<Vec<String>>,

    /// rust type which describes a connection, for example: "diesel::r2d2::PooledConnection<diesel::r2d2::ConnectionManager<diesel::PgConnection>>"
    #[arg(short = 'c', long = "connection-type")]
    pub connection_type: String,

    /// Disable generating serde implementations
    #[arg(long = "no-serde")]
    pub no_serde: bool,

    /// Set custom schema use path, Default "crate::schema::"
    #[arg(long = "schema-path", default_value = "crate::schema::")]
    pub schema_path: String,

    /// Set custom model use path, Default "crate::models::"
    #[arg(long = "model-path", default_value = "crate::models::")]
    pub model_path: String,

    /// Only generate the necessary diesel derives for a struct
    #[arg(long = "only-necessary-derives")]
    pub only_necessary_derives: bool,

    /// Only generate common structs once and put them in a common file
    #[arg(long = "once-common-structs")]
    pub once_common_structs: bool,

    /// Only generate a single model file instead of a folder with a "mod.rs" and a "generated.rs"
    #[arg(long = "single-model-file")]
    pub single_model_file: bool,

    /// Set which file mode to use
    /// "mod.rs" file will still be updated if necessary
    #[arg(long = "file-mode", value_enum, verbatim_doc_comment, default_value_t=FileMode::Overwrite)]
    pub file_mode: FileMode,

    /// A prefix to treat a table as read-only, like "view_"
    #[arg(long = "read-only-prefix")]
    pub read_only_prefix: Option<Vec<String>>,

    /// Dont generate any "impl" and only generate the model structs themself
    #[arg(long = "no-impls")]
    pub no_impls: bool,

    /// Only generate the type "Connection" once and put it in "common.rs"
    #[arg(long = "once-connection")]
    pub once_connection: bool,
}

#[derive(ValueEnum, Clone, Debug, PartialEq, Copy)]
#[value(rename_all = "lowercase")]
pub enum FileMode {
    /// Overwrite the file path, as long as a dsync signature is present
    Overwrite,
    /// Create a ".dsyncnew.rs" file if original is changed
    NewFile,
    /// Do nothing for the file
    None,
}

impl From<FileMode> for dsync_hasezoey::FileMode {
    fn from(value: FileMode) -> Self {
        use dsync_hasezoey::FileMode as libFileMode;
        match value {
            FileMode::Overwrite => libFileMode::Overwrite,
            FileMode::NewFile => libFileMode::NewFile,
            FileMode::None => libFileMode::None,
        }
    }
}
